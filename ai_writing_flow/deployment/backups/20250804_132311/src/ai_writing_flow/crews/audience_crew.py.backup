"""
Audience Crew - Maps content to target audiences and calibrates messaging
"""

from crewai import Agent, Crew, Task
from crewai.tools import tool
from typing import Dict, Any, List
import json
import logging
import re
import os

from ..models import AudienceAlignment

# Disable CrewAI memory logs
os.environ["CREWAI_STORAGE_LOG_ENABLED"] = "false"

logger = logging.getLogger(__name__)


# Define audiences at module level for tool access
VECTOR_WAVE_AUDIENCES = {
    "technical_founder": {
        "description": "Pragmatic builders seeking efficient solutions",
        "values": ["ROI", "scalability", "proven results"],
        "pain_points": ["time constraints", "technical debt", "team productivity"],
        "preferred_depth": 2
    },
    "senior_engineer": {
        "description": "Tech leaders evaluating tools and practices",
        "values": ["code quality", "best practices", "innovation"],
        "pain_points": ["legacy systems", "team alignment", "technical excellence"],
        "preferred_depth": 3
    },
    "decision_maker": {
        "description": "Strategic thinkers planning digital transformation",
        "values": ["business impact", "competitive advantage", "risk management"],
        "pain_points": ["market pressure", "resource allocation", "change management"],
        "preferred_depth": 1
    },
    "skeptical_learner": {
        "description": "Critical thinkers questioning AI hype",
        "values": ["evidence", "transparency", "realistic expectations"],
        "pain_points": ["information overload", "unproven claims", "implementation complexity"],
        "preferred_depth": 2
    }
}


@tool("Get Audience List")
def get_audience_list() -> str:
    """Get list of all target audiences with their characteristics"""
    audience_info = []
    for key, audience in VECTOR_WAVE_AUDIENCES.items():
        info = f"{key}: {audience['description']}"
        info += f"\n  Values: {', '.join(audience['values'])}"
        info += f"\n  Pain points: {', '.join(audience['pain_points'])}"
        info += f"\n  Preferred depth: {audience['preferred_depth']}"
        audience_info.append(info)
    
    return "Target audiences:\n" + "\n\n".join(audience_info)


class AudienceCrew:
    """Crew responsible for audience alignment and messaging calibration"""
    
    def __init__(self):
        # Reference module-level audiences
        self.audiences = VECTOR_WAVE_AUDIENCES
    
@tool("Calculate Topic Fit Score")
def calculate_topic_fit_score(topic: str, audience_key: str, platform: str = "LinkedIn") -> str:
    """Calculate how well a topic fits a specific audience"""
    if audience_key not in VECTOR_WAVE_AUDIENCES:
        return f"Error: Unknown audience key '{audience_key}'. Available: {list(VECTOR_WAVE_AUDIENCES.keys())}"
    
    audience = VECTOR_WAVE_AUDIENCES[audience_key]
    
    # Scoring algorithm
    score = 0.5  # Base score
    
    # Check if topic addresses pain points
    topic_lower = topic.lower()
    for pain_point in audience["pain_points"]:
        if any(word in topic_lower for word in pain_point.split()):
            score += 0.1
    
    # Check if topic aligns with values
    for value in audience["values"]:
        if any(word in topic_lower for word in value.split()):
            score += 0.1
    
    # Platform-specific adjustments
    if platform.lower() == "twitter" and audience_key in ["technical_founder", "senior_engineer"]:
        score += 0.1
    elif platform.lower() == "linkedin" and audience_key == "decision_maker":
        score += 0.1
    
    final_score = min(score, 1.0)
    
    return f"Topic '{topic}' fit score for {audience_key}: {final_score:.2f}/1.0\nReasoning: Analyzed against {len(audience['pain_points'])} pain points and {len(audience['values'])} values"
    
@tool("Generate Key Message")
def generate_key_message(topic: str, audience_key: str, platform: str = "LinkedIn") -> str:
    """Generate key message for specific audience and platform"""
    if audience_key not in VECTOR_WAVE_AUDIENCES:
        return f"Error: Unknown audience key '{audience_key}'"
    
    messages = {
        "technical_founder": f"How {topic} drives 3x productivity without adding complexity",
        "senior_engineer": f"Deep dive: Implementing {topic} with clean architecture patterns",
        "decision_maker": f"Strategic guide: Why {topic} is your competitive advantage in 2024",
        "skeptical_learner": f"No BS analysis: What {topic} actually delivers (with data)"
    }
    
    platform_adjustments = {
        "Twitter": " (thread format with clear hooks)",
        "LinkedIn": " (professional tone with industry insights)",
        "Newsletter": " (in-depth with actionable takeaways)"
    }
    
    message = messages.get(audience_key, f"Exploring {topic}")
    adjustment = platform_adjustments.get(platform, "")
    
    return f"{message}{adjustment}"
    
@tool("Analyze All Audiences")
def analyze_all_audiences(topic: str, platform: str = "LinkedIn") -> str:
    """Analyze topic fit for ALL target audiences and return complete analysis"""
    results = []
    scores = {}
    
    for audience_key in VECTOR_WAVE_AUDIENCES.keys():
        # Calculate score using the original function logic directly
        audience = VECTOR_WAVE_AUDIENCES[audience_key]
        
        # Scoring algorithm (copied from calculate_topic_fit_score)
        score = 0.5  # Base score
        
        # Check if topic addresses pain points
        topic_lower = topic.lower()
        for pain_point in audience["pain_points"]:
            if any(word in topic_lower for word in pain_point.split()):
                score += 0.1
        
        # Check if topic aligns with values
        for value in audience["values"]:
            if any(word in topic_lower for word in value.split()):
                score += 0.1
        
        # Platform-specific adjustments
        if platform.lower() == "twitter" and audience_key in ["technical_founder", "senior_engineer"]:
            score += 0.1
        elif platform.lower() == "linkedin" and audience_key == "decision_maker":
            score += 0.1
        
        final_score = min(score, 1.0)
        scores[audience_key] = final_score
        
        # Generate key message logic (copied from generate_key_message)
        messages = {
            "technical_founder": f"How {topic} drives 3x productivity without adding complexity",
            "senior_engineer": f"Deep dive: Implementing {topic} with clean architecture patterns",
            "decision_maker": f"Strategic guide: Why {topic} is your competitive advantage in 2024",
            "skeptical_learner": f"No BS analysis: What {topic} actually delivers (with data)"
        }
        
        platform_adjustments = {
            "Twitter": " (thread format with clear hooks)",
            "LinkedIn": " (professional tone with industry insights)",
            "Newsletter": " (in-depth with actionable takeaways)"
        }
        
        message = messages.get(audience_key, f"Exploring {topic}")
        adjustment = platform_adjustments.get(platform, "")
        key_message = f"{message}{adjustment}"
        
        results.append(f"=== {audience_key.upper()} ===")
        results.append(f"Topic '{topic}' fit score for {audience_key}: {final_score:.2f}/1.0")
        results.append(f"Reasoning: Analyzed against {len(audience['pain_points'])} pain points and {len(audience['values'])} values")
        results.append(f"Key message: {key_message}")
        results.append("")
    
    # Find primary audience
    primary_audience = max(scores.items(), key=lambda x: x[1])[0]
    recommended_depth = VECTOR_WAVE_AUDIENCES[primary_audience]["preferred_depth"]
    
    # Add summary
    results.append("=== SUMMARY ===")
    results.append(f"Primary audience: {primary_audience} (score: {scores[primary_audience]:.2f})")
    results.append(f"Recommended content depth: Level {recommended_depth}")
    results.append(f"All scores: {json.dumps(scores, indent=2)}")
    
    return "\n".join(results)
    
@tool("Calibrate Tone")
def calibrate_tone(primary_audience: str) -> str:
    """Determine optimal tone for primary audience"""
    tone_map = {
        "technical_founder": "Direct, practical, ROI-focused. Skip theory, show results.",
        "senior_engineer": "Technical but accessible. Include code examples and architecture.",
        "decision_maker": "Strategic and visionary. Focus on outcomes and transformation.",
        "skeptical_learner": "Honest and evidence-based. Address concerns upfront."
    }
    
    tone = tone_map.get(primary_audience, "Balanced and informative")
    return f"Recommended tone for {primary_audience}: {tone}"


class AudienceCrew:
    """Crew responsible for audience alignment and messaging calibration"""
    
    def __init__(self):
        # Reference module-level audiences
        self.audiences = VECTOR_WAVE_AUDIENCES
    
    def audience_mapper_agent(self) -> Agent:
        """Create the audience mapping specialist agent"""
        return Agent(
            role="Audience Strategy Specialist",
            goal="Analyze audience fit and provide recommendations in exactly 3 steps",
            backstory="""You are a seasoned audience strategist with deep expertise in technical 
            content marketing. You excel at analyzing audiences systematically and providing 
            clear, actionable recommendations.
            
            IMPORTANT: You must complete your analysis in EXACTLY 3 steps:
            1. Analyze all audiences
            2. Calibrate tone for primary audience  
            3. Provide final answer
            
            Do NOT continue analyzing after these steps.""",
            tools=[
                analyze_all_audiences,
                calibrate_tone
            ],
            verbose=True,
            allow_delegation=False,
            max_iter=5  # Limit iterations to prevent infinite loops
        )
    
    def create_audience_task(self, topic: str, platform: str, research_summary: str, 
                           editorial_recommendations: str) -> Task:
        """Create an audience alignment task that forces tool usage"""
        return Task(
            description=f"""
            Analyze audience alignment for: {topic}
            Platform: {platform}
            
            Research Summary: {research_summary}
            Editorial Guidance: {editorial_recommendations}
            
            Execute EXACTLY these 3 steps, then STOP:
            
            Step 1: Use "Analyze All Audiences" tool to analyze "{topic}" for "{platform}"
            Step 2: Use "Calibrate Tone" tool with the primary audience from Step 1
            Step 3: Return your final answer with the complete analysis
            
            After completing these 3 steps, you MUST provide your final answer. Do NOT continue using tools after step 2.
            """,
            agent=self.audience_mapper_agent(),
            expected_output="""Final answer must include:
            1. Audience scores for all 4 audiences (from Analyze All Audiences output)
            2. Primary audience identification
            3. Recommended content depth level (1-3)
            4. Tone calibration advice (from Calibrate Tone output)
            5. Key messages for each audience
            
            Format as a structured report, not as tool outputs."""
        )
    
    def execute(self, topic: str, platform: str, research_summary: str, 
                editorial_recommendations: str) -> AudienceAlignment:
        """Execute audience mapping crew with proper tool usage"""
        logger.info("🎯 Starting CrewAI audience analysis...")
        
        # Create crew with single agent
        crew = Crew(
            agents=[self.audience_mapper_agent()],
            tasks=[self.create_audience_task(topic, platform, research_summary, editorial_recommendations)],
            verbose=True
        )
        
        # Execute crew
        result = crew.kickoff()
        
        logger.info("🔧 Parsing crew output into AudienceAlignment...")
        
        # Parse result to extract scores and recommendations
        # In production, this would be more sophisticated
        result_text = str(result)
        
        # Try to extract scores from the result
        scores = {}
        if "All scores:" in result_text:
            try:
                # Extract JSON from result
                json_start = result_text.find("All scores:") + len("All scores:")
                json_end = result_text.find("}", json_start) + 1
                json_section = result_text[json_start:json_end].strip()
                scores = json.loads(json_section)
            except:
                logger.warning("Could not parse scores from crew output, using defaults")
        
        # Default scores if parsing failed
        if not scores:
            scores = {
                "technical_founder": 0.7,
                "senior_engineer": 0.6,
                "decision_maker": 0.5,
                "skeptical_learner": 0.8
            }
        
        # Find primary audience
        primary_audience = max(scores.items(), key=lambda x: x[1])[0]
        recommended_depth = self.audiences[primary_audience]["preferred_depth"]
        
        # Extract key messages from result if possible
        key_messages = {}
        for audience_key in self.audiences.keys():
            # Try to find key message in output
            pattern = f"Key message: (.*?)(?=\n|$)"
            matches = re.findall(pattern, result_text)
            if matches:
                # Map messages to audiences based on order
                audience_list = list(self.audiences.keys())
                for i, msg in enumerate(matches[:len(audience_list)]):
                    key_messages[audience_list[i]] = msg
            else:
                # Fallback to generate
                key_messages[audience_key] = f"Tailored message for {audience_key}"
        
        # Extract tone calibration
        tone_pattern = r"Recommended tone for \w+: (.*?)(?=\n|$)"
        tone_match = re.search(tone_pattern, result_text)
        if tone_match:
            tone_calibration = tone_match.group(1)
        else:
            tone_calibration = "Direct, practical, ROI-focused"
        
        logger.info(f"✅ Audience mapping complete. Primary: {primary_audience}")
        
        return AudienceAlignment(
            technical_founder_score=scores.get("technical_founder", 0.7),
            senior_engineer_score=scores.get("senior_engineer", 0.6),
            decision_maker_score=scores.get("decision_maker", 0.5),
            skeptical_learner_score=scores.get("skeptical_learner", 0.8),
            recommended_depth=recommended_depth,
            tone_calibration=tone_calibration,
            key_messages=key_messages
        )